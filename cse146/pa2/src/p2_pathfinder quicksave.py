from heapq import heappop, heappushimport mathdef calculate_dist(p1, p2):    num = pow(p1[0] - p2[0], 2) + pow(p1[1] - p2[1], 2)    num = math.sqrt(num)    return numdef heuristic(p1, p2):    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])def get_target_point(currPoint, nextBox):        nextBox_is_up = False    nextBox_is_down = False    nextBox_is_left = False    nextBox_is_right = False    # currPoint y, x    # BOXES ARE y1, y2, x1, x2    if currPoint[0] >= nextBox[1]: # next box is above currPoint        nextBox_is_up = True    if currPoint[0] <= nextBox[0]: # next box is below currPoint        nextBox_is_down = True    if currPoint[1] >= nextBox[3]: # next box is to the left of currPoint        nextBox_is_left = True    if currPoint[1] <= nextBox[2]: # next box is to the right of currPoint        nextBox_is_right = True    if nextBox_is_up and nextBox_is_left:        tarPoint = (nextBox[1], nextBox[3])    elif nextBox_is_up and nextBox_is_right:        tarPoint = (nextBox[1], nextBox[2])    elif nextBox_is_up and nextBox_is_right == False and nextBox_is_left == False:        tarPoint = (nextBox[1], currPoint[1])    if nextBox_is_down and nextBox_is_left:        tarPoint = (nextBox[0], nextBox[3])    elif nextBox_is_down and nextBox_is_right:        tarPoint = (nextBox[0], nextBox[2])    elif nextBox_is_down and nextBox_is_right == False and nextBox_is_left == False:        tarPoint = (nextBox[0], currPoint[1])    if nextBox_is_left and nextBox_is_up:        tarPoint = (nextBox[1], nextBox[3])    elif nextBox_is_left and nextBox_is_down:        tarPoint = (nextBox[0], nextBox[3])    elif nextBox_is_left and nextBox_is_up == False and nextBox_is_down == False:        tarPoint = (currPoint[0], nextBox[3])    if nextBox_is_right and nextBox_is_up:        tarPoint = (nextBox[1], nextBox[2])    elif nextBox_is_right and nextBox_is_down:        tarPoint = (nextBox[0], nextBox[2])    elif nextBox_is_right and nextBox_is_up == False and nextBox_is_down == False:        tarPoint = (currPoint[0], nextBox[2])        # tempX = tarPoint[1]    # tempY = tarPoint[0]    # tarPoint = (tempX, tempY)    return tarPointdef get_detail_points(boxes, detail_points, path, destBox, startBox, destination_point, source_point):    detail_points.clear()    for box in boxes:        if boxes[box] == None:            currPoint = get_target_point(detail_points[box], startBox)            path.append((detail_points[box], currPoint))            path.append((currPoint, source_point))            break        if box == destBox:            detail_points[box] = get_target_point(destination_point, boxes[box])            print(detail_points)            currPoint = detail_points[box]            path.append((destination_point, currPoint))        else:            currPoint = detail_points[box]        detail_points[boxes[box]] = get_target_point(currPoint, boxes[box])        path.append((currPoint, detail_points[boxes[box]]))def find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    print(source_point)    print(destination_point)    path = []    boxes = {}    came_from = {}    detail_points = {}    startBox = None    destBox = None    startFound = False    destFound = False    for box in mesh['boxes']:        if box[0] <= source_point[0] and source_point[0] <= box[1] and box[2] <= source_point[1] and source_point[1] <= box[3]:                            startBox = box            print("START FOUND: ", box)            startFound = True            came_from[box] = None        if box[0] <= destination_point[0] and destination_point[0] <= box[1] and box[2] <= destination_point[1] and destination_point[1] <= box[3]:            print("DESTINATION FOUND: ", box)            destFound = True            destBox = box                    if startFound and destFound:            break    queue = []    heappush(queue, (0, startBox))    distances = {}    distances[startBox] = 0    detail_points = {}    while queue and startFound and destFound:        current_dist, current = heappop(queue)        if startBox == destBox:            path.append((source_point, destination_point))            break        point = None        if(current == startBox):            point = source_point        else:            point = detail_points[came_from[current]]        if current == destBox:            # detail_points[current] = get_target_point(point, current)            while current != startBox:                boxes[current] = came_from[current]                current = came_from[current]            boxes[startBox] = None            get_detail_points(boxes, detail_points, path, destBox, startBox, destination_point, source_point)            break        for next in mesh['adj'][current]:            target_point = get_target_point(point, next)            total_dist = calculate_dist(point, target_point) + current_dist            if next not in distances or total_dist < distances[next]:                detail_points[current] = target_point                distances[next] = total_dist                priority = total_dist + heuristic(point, destination_point)                heappush(queue, (priority, next))                came_from[next] = current                # #TODO IF TIME: Exit the moment user clicks on dark line        if len(queue) == 0 or startFound == False or destFound == False:         print('path not found')        # for box in boxes:    #     if came_from[box] == None:    #         point = get_target_point(detail_points[box], startBox)    #         path.append((detail_points[box], point))    #         path.append((point, source_point))    #         break    #     path.append((detail_points[box], detail_points[came_from[box]]))    """        # What we need:            - Merge the two loops together for Dijkstra's:                          - Test case when both points are in the same box            - A helper funciton to calculate distance from point to distanation:            def calculate_dist(pointA, pointB):                sqrt((pointB.x - pointA.x)^2 + (pointB.y- pointA.y)^2)                            - A dict that keeps tracck of distance and points                distances = {key: point (x,y), value: distance so far}            - A Dijkstra's Algo that uses the distance as priority               which according to word doc: "Instead of using the new distance               (distance to u plus length of edge u--v) as the priority for insertion, augment               this with (add to it) an estimate of the distance remaining."    """        # at the end    print("DETAIL POINTS: ", len(detail_points))    print("BOXES: ", len(boxes))    print("PATH: ", len(path))        # print(boxes)    #     return path, boxes.keys()