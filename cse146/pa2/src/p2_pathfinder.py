from heapq import heappop, heappushdef get_target_point(currPoint, nextBox):        nextBox_is_up = False    nextBox_is_down = False    nextBox_is_left = False    nextBox_is_right = False    # currPoint y, x    # BOXES ARE y1, y2, x1, x2    if currPoint[0] >= nextBox[1]: # next box is above currPoint        nextBox_is_up = True    if currPoint[0] <= nextBox[0]: # next box is below currPoint        nextBox_is_down = True    if currPoint[1] >= nextBox[3]: # next box is to the left of currPoint        nextBox_is_left = True    if currPoint[1] <= nextBox[2]: # next box is to the right of currPoint        nextBox_is_right = True    if nextBox_is_up and nextBox_is_left:        tarPoint = (nextBox[1], nextBox[3])    elif nextBox_is_up and nextBox_is_right:        tarPoint = (nextBox[1], nextBox[2])    elif nextBox_is_up and nextBox_is_right == False and nextBox_is_left == False:        tarPoint = (nextBox[1], currPoint[1])    if nextBox_is_down and nextBox_is_left:        tarPoint = (nextBox[0], nextBox[3])    elif nextBox_is_down and nextBox_is_right:        tarPoint = (nextBox[0], nextBox[2])    elif nextBox_is_down and nextBox_is_right == False and nextBox_is_left == False:        tarPoint = (nextBox[0], currPoint[1])    if nextBox_is_left and nextBox_is_up:        tarPoint = (nextBox[1], nextBox[3])    elif nextBox_is_left and nextBox_is_down:        tarPoint = (nextBox[0], nextBox[3])    elif nextBox_is_left and nextBox_is_up == False and nextBox_is_down == False:        tarPoint = (currPoint[0], nextBox[3])    if nextBox_is_right and nextBox_is_up:        tarPoint = (nextBox[1], nextBox[2])    elif nextBox_is_right and nextBox_is_down:        tarPoint = (nextBox[0], nextBox[2])    elif nextBox_is_right and nextBox_is_up == False and nextBox_is_down == False:        tarPoint = (currPoint[0], nextBox[2])        # tempX = tarPoint[1]    # tempY = tarPoint[0]    # tarPoint = (tempX, tempY)    return tarPointdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    print(source_point)    print(destination_point)    path = []    boxes = {}    came_from = {}    detail_points = {}    startBox = None    destBox = None    startFound = False    destFound = False    for box in mesh['boxes']:        if box[0] <= source_point[0] and source_point[0] <= box[1] and box[2] <= source_point[1] and source_point[1] <= box[3]:                            startBox = box            print("START FOUND: ", box)            startFound = True            came_from[box] = None        if box[0] <= destination_point[0] and destination_point[0] <= box[1] and box[2] <= destination_point[1] and destination_point[1] <= box[3]:            print("DESTINATION FOUND: ", box)            destFound = True            destBox = box                    if startFound and destFound:            break    queue = [startBox]    while queue and startFound and destFound:        current = heappop(queue)        if current == destBox:            while current != startBox:                boxes[current] = came_from[current]                current = came_from[current]            boxes[startBox] = None            break        for next in mesh['adj'][current]:            if next not in came_from:                heappush(queue, next)                came_from[next] = current                # #TODO IF TIME: Exit the moment user clicks on dark line        if len(queue) == 0 or startFound == False or destFound == False:         print('path not found')    for box in boxes:        if boxes[box] == None:            currPoint = get_target_point(detail_points[box], startBox)            path.append((detail_points[box], currPoint))            path.append((currPoint, source_point))            break        if box == destBox:            detail_points[box] = get_target_point(destination_point, boxes[box])            print(detail_points)            currPoint = detail_points[box]            path.append((destination_point, currPoint))        else:            currPoint = detail_points[box]        detail_points[boxes[box]] = get_target_point(currPoint, boxes[box])        path.append((currPoint, detail_points[boxes[box]]))        # at the end    print(detail_points)    print(boxes)    print(path)        # print(boxes)    #     return path, boxes.keys()